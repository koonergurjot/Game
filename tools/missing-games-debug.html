<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Missing Games Checker — DEBUG</title>
<style>
  :root{--bg:#0b0f1a;--fg:#e6edf3;--muted:#9aa4b2;--bad:#ff6b6b;--ok:#8de77b;--warn:#ffd166;--card:#111726;}
  body{margin:0;font-family:system-ui,Segoe UI,Roboto,Ubuntu;color:var(--fg);background:radial-gradient(900px 600px at 50% -150px,#162042,var(--bg));}
  header{padding:1rem 1.25rem;background:linear-gradient(180deg,#0f1730,var(--card));border-bottom:1px solid #1b2440;}
  h1{margin:0;font-size:1.25rem}
  main{padding:1rem 1.25rem;max-width:1100px;margin:auto}
  .card{padding:1rem;border:1px solid #1b2440;background:#0f1426;border-radius:.75rem;margin:1rem 0}
  .controls{display:flex;flex-wrap:wrap;gap:.5rem;margin:.5rem 0}
  textarea, input[type="text"]{width:100%;background:#0b1120;color:var(--fg);border:1px solid #1b2440;border-radius:.5rem;padding:.5rem}
  textarea{min-height:120px}
  button{background:#6ea8fe;color:#081121;border:none;padding:.5rem .8rem;border-radius:.5rem;font-weight:600;cursor:pointer}
  pre{white-space:pre-wrap;word-break:break-word;background:#0b1120;border:1px solid #1b2440;padding:.5rem;border-radius:.5rem;max-height:320px;overflow:auto}
  .row{display:grid;grid-template-columns:1fr auto auto auto;gap:.75rem;align-items:center;padding:.6rem .75rem;border:1px solid #1b2440;background:#0f1426;border-radius:.75rem;margin:.5rem 0}
  .slug{font-weight:700}
  .status.ok{color:var(--ok)} .status.missing{color:var(--bad)} .status.warn{color:var(--warn)}
  .small{color:var(--muted);font-size:.9rem}
  .console{background:#0b1120;border:1px solid #1b2440;border-radius:.5rem;padding:.5rem;max-height:300px;overflow:auto;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:.9rem}
  .line{margin:.2rem 0}
  .err{color:#ff7a7a}
  .warn{color:#ffd166}
  .ok{color:#8de77b}
</style>
</head>
<body>
<header>
  <h1>Missing Games Checker — DEBUG</h1>
  <div class="small">Inline logs + error capture. If buttons do nothing, copy the log below and send it to me.</div>
</header>
<main>
  <div class="card">
    <div class="small">games.json URL (edit if needed):</div>
    <input id="jsonUrl" type="text" placeholder="../games.json" value="../games.json"/>
    <div class="controls">
      <button id="btn-load">Load from URL</button>
      <button id="btn-test">Test candidates</button>
      <button id="btn-clear">Clear results</button>
      <button id="btn-ping">Ping (should log a message)</button>
    </div>
    <div id="json-info" class="small"></div>
    <div id="json-preview"></div>
  </div>

  <div class="card">
    <div class="small">Paste slugs or JSON (array / {games:[...]} / object map):</div>
    <textarea id="manual"></textarea>
    <div class="controls"><button id="btn-run">Run check on pasted list</button></div>
  </div>

  <div class="card">
    <div class="small">Inline Console (auto-captures errors):</div>
    <div id="log" class="console"></div>
  </div>

  <div id="list"></div>
</main>
<script>
(function(){
  const logEl = document.getElementById('log');
  function log(msg, cls=''){ const d=document.createElement('div'); d.className='line '+cls; d.textContent = '['+new Date().toISOString().slice(11,19)+'] '+msg; logEl.append(d); logEl.scrollTop = logEl.scrollHeight; }
  function info(m){ log(m, ''); }
  function ok(m){ log(m, 'ok'); }
  function warn(m){ log(m, 'warn'); }
  function err(m){ log(m, 'err'); }

  window.addEventListener('error', (e) => err('window.onerror: '+(e.message||e.error)));
  window.addEventListener('unhandledrejection', (e) => err('unhandledrejection: '+(e.reason && e.reason.message || e.reason)));

  info('Script started. userAgent='+navigator.userAgent);
  info('Location='+location.href);
  if (location.protocol === 'file:') warn('This is file:// — fetch may be blocked. Host on Netlify/GitHub Pages.');

  const list = document.getElementById('list');
  const jsonInfo = document.getElementById('json-info');
  const jsonPreview = document.getElementById('json-preview');
  const jsonUrl = document.getElementById('jsonUrl');

  function clearResults(){ list.innerHTML = ''; jsonPreview.textContent=''; jsonInfo.textContent=''; }
  function preview(obj){ try{ const s=JSON.stringify(obj, null, 2); jsonPreview.innerHTML='<pre>'+s+'</pre>'; }catch(e){ err('preview stringify failed: '+e.message); } }

  const fallbackEntryForSlug = (slug) => `/games/${slug}/index.html`;

  function normalizeToDescriptors(data){
    const out = [];
    const coerceSlug = (value, fallback) => {
      if (typeof value === 'string') return value.trim();
      if (value && typeof value === 'object'){
        const candidate = value.slug || value.id || value.name || (value.path && String(value.path).split('/').filter(Boolean).slice(-2,-1)[0]);
        if (candidate) return String(candidate).trim();
      }
      if (fallback) return String(fallback).trim();
      return '';
    };
    const pushDescriptor = (slug, entry) => {
      const cleanSlug = coerceSlug(slug);
      if (!cleanSlug) return;
      const preferred = entry && typeof entry === 'string' ? entry.trim() : '';
      out.push({ slug: cleanSlug, url: preferred || fallbackEntryForSlug(cleanSlug) });
    };

    if (Array.isArray(data)){
      data.forEach(item => {
        if (typeof item === 'string'){
          pushDescriptor(item);
        } else if (item && typeof item === 'object'){
          const slug = coerceSlug(item);
          pushDescriptor(slug, item.entry || item.url || item.href || item.path);
        }
      });
    } else if (data && typeof data === 'object'){
      if (Array.isArray(data.games)) return normalizeToDescriptors(data.games);
      Object.keys(data).forEach(key => {
        const value = data[key];
        if (typeof value === 'string'){
          pushDescriptor(key, value);
        } else if (value && typeof value === 'object'){
          const slug = coerceSlug(value, key);
          pushDescriptor(slug || key, value.entry || value.url || value.href || value.path);
        } else {
          pushDescriptor(key);
        }
      });
    }

    return out;
  }

  async function probe(url){
    try {
      const res = await fetch(url, { method: 'HEAD', cache: 'no-store' });
      info('HEAD '+url+' → '+res.status);
      if (res.status === 200) return {status:'ok', code:200};
      if (res.status === 404) return {status:'missing', code:404};
      return {status:'warn', code:res.status};
    } catch (e) { err('HEAD '+url+' → ERR '+e.message); return {status:'warn', code:'ERR'}; }
  }

  function row(slug, path, out){
    const div = document.createElement('div');
    div.className = 'row';
    div.innerHTML = `
      <div class="slug">${slug}</div>
      <div class="small">${path}</div>
      <div class="status ${out.status}">${out.status.toUpperCase()}</div>
      <div class="small">${out.code}</div>
    `;
    return div;
  }

  async function runForDescriptors(descriptors){
    if (!descriptors.length){
      warn('runForDescriptors: no descriptors provided');
      const div = document.createElement('div');
      div.className = 'row';
      div.innerHTML = '<div class="slug">No slugs found</div><div class="small">Provide games.json or paste list above.</div><div class="status warn">WARN</div><div class="small">N/A</div>';
      list.append(div);
      return;
    }
    for (const descriptor of descriptors){
      const slug = descriptor && descriptor.slug ? descriptor.slug : '(unknown)';
      const target = descriptor && descriptor.url ? descriptor.url : fallbackEntryForSlug(slug);
      const out = await probe(target);
      list.append(row(slug, target, out));
    }
  }

  async function loadFromUrl(url){
    clearResults();
    info('Fetching '+url+' …');
    jsonInfo.textContent = 'Loading '+url+'…';
    try{
      const res = await fetch(url, { cache: 'no-store' });
      info('GET '+url+' → '+res.status);
      if (!res.ok){ jsonInfo.textContent = 'HTTP '+res.status+' from '+url; preview({error:'non-ok', status:res.status}); return; }
      const data = await res.json();
      ok('Parsed JSON from '+url);
      preview(data);
      const descriptors = normalizeToDescriptors(data);
      ok('Extracted '+descriptors.length+' slug(s)');
      jsonInfo.textContent = 'Loaded '+descriptors.length+' slug(s) from '+url;
      await runForDescriptors(descriptors);
    }catch(e){
      err('Fetch failed: '+(e.message||e));
      jsonInfo.textContent = 'Error fetching '+url+' — see console below.';
      preview({ error: String(e) });
    }
  }

  document.getElementById('btn-load').addEventListener('click', () => loadFromUrl(jsonUrl.value.trim() || '../games.json'));
  document.getElementById('btn-test').addEventListener('click', async () => {
    const cands = ['../games.json','./games.json','/games.json','../assets/games.json','../public/games.json'];
    for (const u of cands){
      try{ const r = await fetch(u, { cache: 'no-store' }); info('TEST '+u+' → '+r.status); }
      catch(e){ err('TEST '+u+' → ERR '+e.message); }
    }
  });
  document.getElementById('btn-clear').addEventListener('click', clearResults);
  document.getElementById('btn-ping').addEventListener('click', () => ok('ping button clicked ✔'));

  document.getElementById('btn-run').addEventListener('click', async () => {
    const text = document.getElementById('manual').value.trim();
    info('Manual run clicked; input length='+text.length);
    let descriptors = [];
    try {
      if (text.startsWith('[') || text.startsWith('{')){
        const data = JSON.parse(text);
        descriptors = normalizeToDescriptors(data);
      } else {
        const slugs = text.split(/\s|,|;|\n|\r/).map(s=>s.trim()).filter(Boolean);
        descriptors = slugs.map(slug => ({ slug, url: fallbackEntryForSlug(slug) }));
      }
      ok('Manual parse got '+descriptors.length+' slug(s)');
      await runForDescriptors(descriptors);
    } catch (e) {
      err('Manual parse failed: '+e.message);
    }
  });

  ok('Handlers bound.');
})(); 
</script>
</body>
</html>
