<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Runtime Diagnosis Â· Gurjot's Games</title>
<style>
  :root { --ok:#0a0; --fail:#c00; --warn:#b58900; --muted:#666; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
  h1 { margin: 0 0 8px; }
  .meta { color: var(--muted); margin-bottom: 16px; }
  table { width: 100%; border-collapse: collapse; }
  th, td { border: 1px solid #e5e7eb; padding: 8px; vertical-align: top; }
  th { background: #f8fafc; text-align: left; }
  iframe { width: 420px; height: 280px; border: 1px solid #ddd; background:#fff; }
  .status { font-weight: 600; }
  .OK { color: var(--ok); }
  .FAIL { color: var(--fail); }
  .WARN { color: var(--warn); }
  .muted { color: var(--muted); }
  details { margin-top: 4px; }
  summary { cursor: pointer; }
  .controls { display:flex; gap:8px; margin: 12px 0 20px; }
  button { padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 8px; background:#fff; cursor:pointer; }
  button:hover { background:#f3f4f6; }
</style>
</head>
<body>
<h1>Runtime Diagnosis</h1>
<div class="meta">Loads each game via <code>game.html?slug=&lt;slug&gt;</code> using the same loader as production. Records READY / ERROR messages.</div>
<div class="controls">
  <button id="reload-all">Reload All</button>
  <button id="clear-logs">Clear Logs</button>
</div>
<table id="report">
  <thead>
    <tr>
      <th style="width:160px">Game</th>
      <th style="width:460px">Preview</th>
      <th style="width:120px">Status</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

<script type="module">
const t = Date.now(); // cache buster
const tbody = document.querySelector('#report tbody');
const mk = (t, props={}) => Object.assign(document.createElement(t), props);

async function loadCatalog() {
  const urls = [`/games.json?cb=${t}`, `/public/games.json?cb=${t}`];
  let lastError = null;
  for (const url of urls) {
    try {
      const res = await fetch(url);
      if (!res?.ok) throw new Error('Failed to fetch games.json');
      return await res.json();
    } catch (err) {
      lastError = err;
    }
  }
  throw lastError || new Error('Failed to fetch games.json');
}

function buildRows(list) {
  tbody.innerHTML = '';
  const sorted = [...list].sort((a,b)=>a.slug.localeCompare(b.slug));
  for (const g of sorted) {
    const tr = mk('tr');
    const name = mk('td');
    const iframeCell = mk('td');
    const status = mk('td', { className: 'status muted', textContent: 'PENDING' });
    const details = mk('td');
    tbody.appendChild(tr);
    tr.append(name, iframeCell, status, details);

    name.innerHTML = `<div><strong>${g.title || g.slug}</strong><div class="muted">${g.slug}</div></div>`;

    const url = `/game.html?slug=${encodeURIComponent(g.slug)}&cb=${t}`;
    const open = mk('a', { href: url, textContent: 'Open', target: '_blank', rel: 'noopener' });
    const iframe = mk('iframe', { src: url });
    iframeCell.append(iframe, mk('div', { style:'margin-top:6px' , appendChild: open }));

    const logs = [];
    const log = (msg) => { logs.push(msg); renderDetails(); };
    const setStatus = (cls, txt) => { status.className = 'status ' + cls; status.textContent = txt; };

    let ready = false;
    const timer = setTimeout(() => {
      if (!ready) { setStatus('WARN','NO SIGNAL'); log('No GAME_READY/ERROR postMessage within 5s'); }
    }, 5000);

    function renderDetails() {
      details.innerHTML = `<details ${logs.length ? 'open':''}><summary>logs (${logs.length})</summary><pre>${logs.join('\n')}</pre></details>`;
    }

    window.addEventListener('message', (ev)=>{
      if (ev.source !== iframe.contentWindow || !ev.data || typeof ev.data !== 'object') return;
      const d = ev.data;
      if (d.slug !== g.slug) return;
      if (d.type === 'GAME_READY') {
        ready = true;
        clearTimeout(timer);
        setStatus('OK','OK');
        log('GAME_READY');
      }
      if (d.type === 'GAME_ERROR') {
        ready = true;
        clearTimeout(timer);
        setStatus('FAIL','FAIL');
        log('GAME_ERROR: ' + (d.message || ''));
      }
    });

    // Network/load failure
    iframe.addEventListener('error', () => {
      clearTimeout(timer);
      setStatus('FAIL','IFRAME LOAD ERROR');
      log('iframe onerror fired');
    });
    iframe.addEventListener('load', () => {
      log('iframe loaded');
    });
  }
}

document.getElementById('reload-all').addEventListener('click', ()=>{
  const frames = document.querySelectorAll('iframe');
  frames.forEach(f => {
    const url = new URL(f.src, location.origin);
    url.searchParams.set('cb', String(Date.now()));
    f.src = url.toString();
  });
});
document.getElementById('clear-logs').addEventListener('click', ()=>{
  const pres = document.querySelectorAll('td details pre');
  pres.forEach(p => p.textContent = '');
});

loadCatalog().then(buildRows).catch(err => {
  tbody.innerHTML = `<tr><td colspan="4" class="muted">Failed to load games.json: ${err && err.message || err}</td></tr>`;
});
</script>
</body>
</html>
